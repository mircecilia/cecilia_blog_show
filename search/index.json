[{"content":"代码内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 # include \u0026lt;stdio.h\u0026gt; int findmin(int a,int b){ return a \u0026gt; b ? b : a; } int findmax(int* arr,int n){ int p = arr[0]; for(int i = 0;i \u0026lt; n;i++){ if(arr[i] \u0026gt;= p){ p = arr[i]; } } return p; } int compute(int* attack,int* defense,int n,int i,int max){ int j = i; int k = i + 1; int need = 0; int attacknow = 0; if(defense[j] \u0026gt; defense[k]){ need = defense[k]; attacknow = need + attack[k]; k++; } else{ need = defense[j]; attacknow = need + attack[j]; j--; } while(j != -1 \u0026amp;\u0026amp; k != n \u0026amp;\u0026amp; defense[j] != max \u0026amp;\u0026amp; defense[k] != max){ if(attacknow \u0026gt;= findmin(defense[j],defense[k])){ if(defense[j] \u0026gt; defense[k]){ attacknow += attack[k]; k++; } if(defense[j] \u0026lt;= defense[k]){ attacknow += attack[j]; j--; } } else{ if(defense[j] \u0026gt; defense[k]){ need = need + defense[k] - attacknow; attacknow = need + attack[k]; k++; } if(defense[j]\u0026lt;=defense[k]){ need = need + defense[j] - attacknow; attacknow = need + attack[j]; j--; } } } while((j == -1 || defense[j] == max) \u0026amp;\u0026amp; (k != n \u0026amp;\u0026amp; defense[k] != max)){ if(attacknow \u0026lt; defense[k]){ need = need + defense[k] - attacknow; attacknow = defense[k] + attack[k]; k++; } else{ attacknow += attack[k]; k++; } } while((k == n || defense[k] == max) \u0026amp;\u0026amp; (j != -1 \u0026amp;\u0026amp; defense[j] != max)){ if(attacknow \u0026lt; defense[j]){ need = need + defense[j] - attacknow; attacknow = defense[j] + attack[j]; j--; } else{ attacknow += attack[j]; j--; } } if((j == -1 || defense[j] == max) \u0026amp;\u0026amp; (k == n || defense[k] == max)){ if(attacknow \u0026lt; max){ need = need + max - attacknow; } else{ return need; } } } int output(int* attack,int* defense,int n){ int p = 0; int max = findmax(defense,n); for(int i = 0;i \u0026lt; n-1;i++){ int need = compute(attack,defense,n,i,max); p = p ^ need; } return p; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int attack[n]; int defense[n]; for(int i = 0;i \u0026lt; n ;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;defense[i]); } for(int i = 0;i \u0026lt; n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;attack[i]); } int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); int show[t]; int cnt = 0; while(t \u0026gt; 0){ int q; scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); if(q == 0){ show[cnt] = output(attack,defense,n); cnt++; } else{ int stored[n]; int storea[n]; for(int i = 0;i \u0026lt; n;i++){ stored[i] = defense[i]; storea[i] = attack[i]; } while(q \u0026gt; 0){ int number, a, d; scanf(\u0026#34;%d\u0026#34;, \u0026amp;number); scanf(\u0026#34;%d\u0026#34;, \u0026amp;d); scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); storea[number - 1] = a; stored[number - 1] = d; q--; } show[cnt] = output(storea,stored,n); cnt++; } t--; } for(int i = 0;i \u0026lt; cnt - 1;i++){ printf(\u0026#34;%d\\n\u0026#34;,show[i]); } printf(\u0026#34;%d\u0026#34;,show[cnt-1]); return 0; } 思路概述 本题的主要思路是双指针，在插入位置的左侧及右侧分别置入 j , k 两个指针，然后检测此时所需攻击力是否大于左右指针指向的任意一个数，若有则击败其中最小的一个，并将所得攻击力加入 attacknow 中，若无，则补上 need 与所需最小攻击力（即最小防御力）的差值，并将 attacknow 设置为该指针指向的梦魇防御力与所得攻击力的和，重复检测直至任意一个指针指向最大值或到达数组边界，再让剩余的一个指针同样到达等效边界（即指向最大值或数组边界），由于能击败梦魇中最高防御力的敌人则证明能击败所有梦魇，所以只要两个指针都指向等效边界，即可检测此时 attacknow 是否能击败防御力最高的敌人，若能则直接返回 need 值，若不能则补全 attacknow 与最高防御力间的差值，然后返回 need 值即可，剩余的都是套壳，注意 coderunner 不能正常返回套壳后的结果，需要先存放至数组中再进行打印\n","date":"2025-03-16T00:38:24+08:00","permalink":"https://mircecilia.netlify.app/p/%E6%A2%A6%E9%AD%87/","title":"梦魇"},{"content":"next数组的计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void computenext (const char* pattern, int m, int* next){ int len = 0; next [0] = 0; int i = 1; while(i \u0026lt; m){ if(pattern[i] == pattern[len]){ len++; next[i] = len; i++; } else{ if(len != 0){ len = next[len-1]; } else{ next[i] = 0; i++; } } } } next 数组的计算本质是查询给定文本的前后缀是否相同，next 数组默认首位为零，以 i 为下标进行检测，i 指向的字母即本次检测字符，若相同则 len 与 i 加一，若不相同，则检测此时不加检测字母的上一次检测是否有相同前后缀（即此时 len 是否为零），若为零则将 i 后移一位继续进行检测，若不为零则回退检测进度\n此处对进度回退进行详细解释：若已确定 i 对应的检测字母不相同，那么此时若存在相同前后缀（即 next[i] != 0），则一定是 i 所指字母与前一位（或多位）字母构成了相同前后缀，无需使用暴力算法进行计算，只需查询去掉 i 所指字母的上一串具有相同前后缀的字符串的 next 数组就可以确定下一次要检测的更小的相同前后缀字符串，类似于对自身进行了递归调用，但采用的是哨兵记法，个人感觉更类似于动态规划切钢管时使用的哨兵版本自底向顶算法\ne.g:\n若给定文本是 \u0026ldquo;abdcabp abdcabe\u0026rdquo;，此时 i 指向 e，检测得到 p 不等于 e，那么只有可能是 \u0026ldquo;\u0026hellip;ab(e)\u0026rdquo; 与前面形成了更短的相同前缀，此时由于在第一次检测 \u0026ldquo;abdcabd\u0026rdquo; 中已经检测过 \u0026ldquo;ab\u0026rdquo; 这个字符串的 next 数组，所以只需查找 \u0026ldquo;abdcab\u0026rdquo; 中第二次 \u0026ldquo;ab\u0026rdquo; 的 next 数组即可得到下一次需要检测的字符串，在本例中就是检测加入 i 所指字母后是否构成 \u0026ldquo;abd\u0026rdquo;\nnext 数组优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void computenextval (const char* pattern, int m, int* next, int* nextval){ nextval[0] = 0; for(int i = 0;i \u0026lt; n;i++){ if(pattern[i] == pattern[next[i] - 1]){ // next[i] 为 j 指针跳过前 n 位重复的字母后的指向 // 而此时需要检测的就是被跳过的最后一位字母是否重复（即指针跳转后的前一位） // 因此需要减去一 nextval[i] = nextval[next[i] - 1]; } else if(pattern[i] != pattern[next[i] - 1]){ nextval[i] = next[i]; } } } nextval 数组本质是对 KMP 算法的提前优化，若 j 指针回退后指向的字母与回退前指向字母相同，则该次回退本无需进行，而 nextval 数组优化了此问题，使得 j 指针无需进行不必要的回退，小幅度优化了长文本串中 KMP 算法的时间复杂度\nKMP算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void kmp (const char* text, const char* pattern){ int i = 0; int j = 0; int n = strlen(pattern); int m = strlen(text); int next[n]; int nextval[n]; computenext(pattern,n,next); computenextval(pattern,n,next,nextval); while(i \u0026lt; m){ if(text[i] == pattern[j]){ i++; j++; } else if(j == n){ printf(\u0026#34;have found! the location is %d\u0026#34;,i-j); j = nextval[j - 1]; } else if(i \u0026lt; n \u0026amp;\u0026amp; text[i] != pattern[j]){ if(j != 0){ j = nextval[j - 1]; // 此处 j - 1 也是先后退 j 指针至还有重复前后缀的最后一位再查 next 数组 } else{ i++; } } } } KMP 算法使用 i 与 j 两个指针分别指向 text 与 pattern 文本，若检测 i 与 j 所指字母相同，则两个指针全部后移，如果 j 指针移动距离与 pattern 字符串长度相等，则返回找到的第一个匹配的位置，回退后继续寻找下一个位置，若两指针所指字母不同，则检测 j 指针是否移动过，若未移动过则证明已检测的 text 中完全不可能含有任何一个字母匹配，后移指针 i 继续检测，若 j 已移动过，则利用 next 数组将 j 指针回退到重叠部分继续检测\ne.g：\n若 text 为 \u0026ldquo;abaacababcac\u0026rdquo;，而 pattern 为 \u0026ldquo;ababc\u0026rdquo;，检测至第四位时两个字母不匹配，此时 j 指针按照 next 数组回退至 pattern 中第二位 \u0026ldquo;b\u0026rdquo;，跳过对第一位 \u0026ldquo;a\u0026rdquo; 的检测，即检测 \u0026ldquo;\u0026hellip;(aa)\u0026hellip;\u0026rdquo; 与 \u0026ldquo;ab\u0026rdquo; 是否相同，此时判断也不相同而无回退位置，从而检测出 text 中前四位 \u0026ldquo;abaa\u0026rdquo; 中完全无可能与 pattern 匹配，此时 i 指针移动至第五位开始新一轮检测\n总结 KMP算法大幅度优化了BF算法使用的按位暴力回溯求解，通过保持指针 i 不动，不断回退移动 j 指针，使得时间复杂度由 O(m*n) 变为 O(m+n)，规避了坏情况对算法稳定度带来的影响\n","date":"2025-03-06T21:30:07+08:00","permalink":"https://mircecilia.netlify.app/p/kmp/","title":"KMP"},{"content":"BST 结点定义 1 2 3 4 5 typedef struct node{ int value; struct node* left; struct node* right; } node; 用值创造结点 1 2 3 4 5 6 7 node* creatNode(int value){ node* newnode = (node*)malloc(sizeof(node)); newnode-\u0026gt;value = value; newnode-\u0026gt;left = NULL; newnode-\u0026gt;right = NULL; return newnode; } 在已有树的基础上插入新结点 1 2 3 4 5 6 7 8 9 10 11 12 node* insert(node* root, int value){ if(root == NULL){ return creatNode(value); } if(value\u0026lt;root-\u0026gt;value){ root-\u0026gt;left = insert(root-\u0026gt;left,value); } else if(value\u0026gt;root-\u0026gt;value){ root-\u0026gt;right = insert(root-\u0026gt;right,value); } return root; } 搜索结点 1 2 3 4 5 6 7 8 9 node* search(node* root,int value){ if(root-\u0026gt;value == value || root == NULL){ return root; } if(value\u0026lt;root-\u0026gt;value){ return search(root-\u0026gt;left,value); } return search(root-\u0026gt;right,value); } 寻找输入树中的最小结点 1 2 3 4 5 6 7 node* findmin(node* root){ node* current = root; while(current != NULL \u0026amp;\u0026amp; current-\u0026gt;left != NULL){ current = current-\u0026gt;left; } return current; } 删除结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 node* delete(node* root, int value){ if(root == NULL){ return root; } if(value \u0026lt; root-\u0026gt;value){ root-\u0026gt;left=delete(root-\u0026gt;left,value); } else if(value \u0026gt; root-\u0026gt;value){ root-\u0026gt;right=delete(root-\u0026gt;right,value); } // 前半部分寻找结点 else if(value == root-\u0026gt;value){ // 找到结点后 if(root-\u0026gt;left == NULL){ // 若删除的结点没有或只有一个结点 node* temp = root-\u0026gt;right; free(root); return temp; } else if(root-\u0026gt;right == NULL){ node* temp = root-\u0026gt;left; free(root); return temp; } // 若结点有两个结点，则找到其右树的最小结点将其代替 node* temp = findmin(root-\u0026gt;right); root-\u0026gt;value = temp-\u0026gt;value; root-\u0026gt;right = delete(root-\u0026gt;right,temp-\u0026gt;value); } return root; } 删除树 1 2 3 4 5 6 7 void freeTree(node* root) { if (root != NULL) { freeTree(root-\u0026gt;left); freeTree(root-\u0026gt;right); free(root); } } AVL 定义结点 1 2 3 4 5 6 typedef struct node{ int data; struct node* left; struct node* right; int height; } node; 获取高度及平衡因子 1 2 3 4 5 6 7 8 9 10 11 12 13 int getheight(node* root){ if(root == NULL){ return 0; } return root-\u0026gt;height; } int getbalance(node* root){ if(root == NULL){ return 0; } return getheight(root-\u0026gt;left) - getheight(root-\u0026gt;right); } 用值创造新的结点 1 2 3 4 5 6 7 8 node* creatnode(int data){ node* root = (node*)malloc(sizeof(node)); root-\u0026gt;data = data; root-\u0026gt;left = NULL; root-\u0026gt;right = NULL; root-\u0026gt;height = 1; return root; } 左旋及右旋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 node* leftrotate(node* root){ node* r = root-\u0026gt;right; node* l = r-\u0026gt;left; r-\u0026gt;left = root; root-\u0026gt;right = l; root-\u0026gt;height = max(getheight(root-\u0026gt;left),getheight(root-\u0026gt;right))+1; r-\u0026gt;height = max(getheight(r-\u0026gt;left),getheight(r-\u0026gt;right))+1; return r; } node* rightrotate(node* root){ node* l = root-\u0026gt;left; node* r = l-\u0026gt;right; l-\u0026gt;right = root; root-\u0026gt;left = r; root-\u0026gt;height = max(getheight(root-\u0026gt;left) , getheight(root-\u0026gt;right))+1; l-\u0026gt;height = max(getheight(l-\u0026gt;left) , getheight(l-\u0026gt;right))+1; return l; } 在此详细解释两种操作：\n左旋操作为储存操作结点root的右结点r，以及右结点r的左结点l，将原root结点下降至原l结点的位置，并将储存的原l结点变为现l结点（即原root结点）的右结点\n右旋操作为储存操作结点root的左结点l，以及左节点l的右结点r，将原root结点下降至原r结点的位置，并将储存的原r结点变为现r结点（即原root结点）的左结点\n两种操作的本质内核都是尽可能降低原树的不平衡度，使原树中没有结点的位置被最大程度利用，从而使得树更加平衡\n插入结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 node* insert(node* root, int data){ if(root==NULL){ return creatnode(data); } if(data \u0026lt; root-\u0026gt;data){ root-\u0026gt;left = insert(root-\u0026gt;left,data); } else if(data \u0026gt; root-\u0026gt;data){ root-\u0026gt;right = insert(root-\u0026gt;right,data); } // 寻找结点应插入的位置 else if(data == root-\u0026gt;data){ return root; // 插入相同结点则返回原有结点 } // 找到插入位置 root-\u0026gt;height = max(getheight(root-\u0026gt;left),getheight(root-\u0026gt;right))+1; // 实时更新树的高度 int balance = getbalance(root); // 计算目前的平衡因子 // 四种情况分类 if(balance \u0026gt; 1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;left) \u0026gt;= 0){ return rightrotate(root); } if(balance \u0026lt; -1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;right) \u0026lt;= 0){ return leftrotate(root); } if(balance \u0026gt; 1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;left) \u0026lt; 0){ root-\u0026gt;left = leftrotate(root-\u0026gt;left); return rightrotate(root); } if(balance \u0026lt; -1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;right) \u0026gt; 0){ root-\u0026gt;right = rightrotate(root-\u0026gt;right); return leftrotate(root); } return root; } 四种分类情况分别代表了不同的失衡类型，若root结点的左树失衡，则第一类型为L，若右树失衡则第一类型为R，再进一步观察失衡树的平衡因子以确定下一步进行左旋还是右旋，左树高则为L型，右树高则为R型\nLL型为左树严重失衡，使用右旋\nRR型为右树严重失衡，使用左旋\nLR型则先左旋左结点变为LL型，再右旋\nRL型则先右旋右结点变为RR型，再左旋\n总结来说，旋转操作的左右旋与类型的R与L相反,按步骤反向进行即可\n删除结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 node* delete(node* root , int data){ if(root == NULL){ return root; } if(data \u0026lt; root-\u0026gt;data){ root-\u0026gt;left = delete(root-\u0026gt;left , data); } else if(data \u0026gt; root-\u0026gt;data){ root-\u0026gt;right = delete(root-\u0026gt;right,data); } // 寻找要删除的结点 else if(data == root-\u0026gt;data){ if(root-\u0026gt;left == NULL){ node* temp = root-\u0026gt;right; free(root); return temp; } else if(root-\u0026gt;right == NULL){ node* temp = root-\u0026gt;left; free(root); return temp; } // 删除结点若没有或只有一个子结点，则直接将子结点返回 else{ node* temp = findmin(root-\u0026gt;right); root-\u0026gt;data = temp-\u0026gt;data; root-\u0026gt;right = delete(root-\u0026gt;right,temp-\u0026gt;data); } // 若含有两个结点，则将其右子树的最小结点替换自身，并删除右子树的最小结点 } if (root == NULL) { // 添加检查 return root; } root-\u0026gt;height = max(getheight(root-\u0026gt;left),getheight(root-\u0026gt;right)) + 1; // 更新树的高度 int balance = getbalance(root); // 更新平衡因子 if (balance \u0026gt; 1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;left) \u0026gt;= 0){ return rightrotate(root); } if (balance \u0026gt; 1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;left) \u0026lt; 0){ root-\u0026gt;left = leftrotate(root-\u0026gt;left); return rightrotate(root); } if(balance \u0026lt; -1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;right) \u0026lt;= 0){ return leftrotate(root); } if(balance \u0026lt; -1 \u0026amp;\u0026amp; getbalance(root-\u0026gt;right) \u0026gt; 0){ root-\u0026gt;right = rightrotate(root-\u0026gt;right); return leftrotate(root); } // 此处四种情况同插入，本质是使新树平衡度提高，提升空间利用率 return root; } 总结 AVL的构建要求高于BST，更加严格\n因此AVL可以防止插入数据顺序过于整齐而导致整个树退化为链表，从而使时间复杂度由 log(n) 提升至 n\nAVL的插入，查找，删除时间复杂度均为 log(n)，但若进行频繁的插入，删除，红黑树的性能会优于AVL,因此 AVL 主要用于查找\n","date":"2025-03-06T16:06:38+08:00","permalink":"https://mircecilia.netlify.app/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E9%98%B6/","title":"二叉树进阶"},{"content":"树的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def tree(label,branches=[]): for branch in branches: assert is tree(branch),\u0026#39;branches must be branch` return [label]+list(branches) def label(tree): return tree[0] def branches(tree): return tree[1:] def is tree(tree): if type(tree)!=list or len(tree)\u0026lt;1: return False for branch in branches(tree): if not is tree(branch): return False return True def is_leaf(tree): return not branches(tree) #test=tree(3,[tree(7),tree(9,[tree(6),tree(0)])]) #print(test) 此处对树，枝干以及树叶进行定义并检测\n斐波那契树 1 2 3 4 5 6 7 8 def fib_tree(n): if n\u0026lt;=1: return tree(1) else: left,right=fib_tree(n-1),fib_tree(n-2) return tree(label(left)+label(right),[left,right]) #test=fib_tree(5) #print(test) 此处可以通过递归自顶向下生成一颗斐波那契树\n树叶计数 1 2 3 4 5 6 7 8 9 def count_leaf(tree): if is_leaf(tree): return 1 else: branches_count=[count_leaf(branch) for branch in branches(tree)] #此处将不同枝干的数据作为列表进行储存，方便使用sum函数进行计算 return sum(branches_count) #test=count_leaf(fib_tree(5)) #print(test) 通过递归对树叶数量进行计算\n树叶展示 1 2 3 4 5 6 7 def leaves(tree): if is_leaf(tree): return [label(tree)] else: return sum([leaves(b) for b in branches(tree)],[]) #test=leaves(fib_tree(5)) #print(test) 此处通过递归进行树叶显示，同时使用指定相加方式的 sum 函数将所有树叶以列表形式展示\n树的修改 增加树叶 1 2 3 4 5 6 def increment_leaves(t): if is_leaf(t): return tree(label(t)+1) else: bs = [increment_leaves(b) for b in branches(t)] return tree(label(t),bs) 此处通过递归检测输入是否为树叶，若是树叶则增加，若非树叶则向下继续检测\n增加枝干 1 2 3 def increment(t): bs = [increment(b) for b in branches(t)] return tree(label(t)+1,bs) 检测原理同上，自顶向下\n以可视化方式打印树 1 2 3 4 def print_tree(t,cnt=0): print(\u0026#39; \u0026#39;*cnt+str(label(t))) for b in branches(tree): print_tree(b,cnt+1) 此处通过控制空格数量将树的不同级枝干分开打印\n检测树不同路径数之和 1 2 3 4 5 6 7 8 9 #t=tree(3,[tree(-1),tree(1,[tree(2,[tree(1)]),tree(3)]),tree(1,[tree(-1)])]) def count_paths(t,total): if label(t)==total: found = 1 else: found = 0 return found + sum([count_paths(b,total-label(t)) for b in branches(t)]) #test=count_paths(t,4) #print(test) 此处仍运用递归，在经过每条路径时检测是否符合要求，若不符合则减去 label 值继续向下检测\n","date":"2025-02-25T14:05:50+08:00","permalink":"https://mircecilia.netlify.app/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9D%E6%AD%A5/","title":"二叉树初步"}]